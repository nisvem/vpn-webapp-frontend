import "./chunk-ZS7NZCD4.js";

// node_modules/date-and-time/esm/date-and-time.mjs
var locales = {};
var plugins = {};
var lang = "en";
var _res = {
  MMMM: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  MMM: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  dddd: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  ddd: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  dd: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  A: ["AM", "PM"]
};
var _formatter = {
  YYYY: function(d) {
    return ("000" + d.getFullYear()).slice(-4);
  },
  YY: function(d) {
    return ("0" + d.getFullYear()).slice(-2);
  },
  Y: function(d) {
    return "" + d.getFullYear();
  },
  MMMM: function(d) {
    return this.res.MMMM[d.getMonth()];
  },
  MMM: function(d) {
    return this.res.MMM[d.getMonth()];
  },
  MM: function(d) {
    return ("0" + (d.getMonth() + 1)).slice(-2);
  },
  M: function(d) {
    return "" + (d.getMonth() + 1);
  },
  DD: function(d) {
    return ("0" + d.getDate()).slice(-2);
  },
  D: function(d) {
    return "" + d.getDate();
  },
  HH: function(d) {
    return ("0" + d.getHours()).slice(-2);
  },
  H: function(d) {
    return "" + d.getHours();
  },
  A: function(d) {
    return this.res.A[d.getHours() > 11 | 0];
  },
  hh: function(d) {
    return ("0" + (d.getHours() % 12 || 12)).slice(-2);
  },
  h: function(d) {
    return "" + (d.getHours() % 12 || 12);
  },
  mm: function(d) {
    return ("0" + d.getMinutes()).slice(-2);
  },
  m: function(d) {
    return "" + d.getMinutes();
  },
  ss: function(d) {
    return ("0" + d.getSeconds()).slice(-2);
  },
  s: function(d) {
    return "" + d.getSeconds();
  },
  SSS: function(d) {
    return ("00" + d.getMilliseconds()).slice(-3);
  },
  SS: function(d) {
    return ("0" + (d.getMilliseconds() / 10 | 0)).slice(-2);
  },
  S: function(d) {
    return "" + (d.getMilliseconds() / 100 | 0);
  },
  dddd: function(d) {
    return this.res.dddd[d.getDay()];
  },
  ddd: function(d) {
    return this.res.ddd[d.getDay()];
  },
  dd: function(d) {
    return this.res.dd[d.getDay()];
  },
  Z: function(d) {
    var offset = d.getTimezoneOffset() / 0.6 | 0;
    return (offset > 0 ? "-" : "+") + ("000" + Math.abs(offset - (offset % 100 * 0.4 | 0))).slice(-4);
  },
  ZZ: function(d) {
    var offset = d.getTimezoneOffset();
    var mod = Math.abs(offset);
    return (offset > 0 ? "-" : "+") + ("0" + (mod / 60 | 0)).slice(-2) + ":" + ("0" + mod % 60).slice(-2);
  },
  post: function(str) {
    return str;
  },
  res: _res
};
var _parser = {
  YYYY: function(str) {
    return this.exec(/^\d{4}/, str);
  },
  Y: function(str) {
    return this.exec(/^\d{1,4}/, str);
  },
  MMMM: function(str) {
    var result = this.find(this.res.MMMM, str);
    result.value++;
    return result;
  },
  MMM: function(str) {
    var result = this.find(this.res.MMM, str);
    result.value++;
    return result;
  },
  MM: function(str) {
    return this.exec(/^\d\d/, str);
  },
  M: function(str) {
    return this.exec(/^\d\d?/, str);
  },
  DD: function(str) {
    return this.exec(/^\d\d/, str);
  },
  D: function(str) {
    return this.exec(/^\d\d?/, str);
  },
  HH: function(str) {
    return this.exec(/^\d\d/, str);
  },
  H: function(str) {
    return this.exec(/^\d\d?/, str);
  },
  A: function(str) {
    return this.find(this.res.A, str);
  },
  hh: function(str) {
    return this.exec(/^\d\d/, str);
  },
  h: function(str) {
    return this.exec(/^\d\d?/, str);
  },
  mm: function(str) {
    return this.exec(/^\d\d/, str);
  },
  m: function(str) {
    return this.exec(/^\d\d?/, str);
  },
  ss: function(str) {
    return this.exec(/^\d\d/, str);
  },
  s: function(str) {
    return this.exec(/^\d\d?/, str);
  },
  SSS: function(str) {
    return this.exec(/^\d{1,3}/, str);
  },
  SS: function(str) {
    var result = this.exec(/^\d\d?/, str);
    result.value *= 10;
    return result;
  },
  S: function(str) {
    var result = this.exec(/^\d/, str);
    result.value *= 100;
    return result;
  },
  Z: function(str) {
    var result = this.exec(/^[+-]\d{2}[0-5]\d/, str);
    result.value = (result.value / 100 | 0) * -60 - result.value % 100;
    return result;
  },
  ZZ: function(str) {
    var arr = /^([+-])(\d{2}):([0-5]\d)/.exec(str) || ["", "", "", ""];
    return { value: 0 - ((arr[1] + arr[2] | 0) * 60 + (arr[1] + arr[3] | 0)), length: arr[0].length };
  },
  h12: function(h, a) {
    return (h === 12 ? 0 : h) + a * 12;
  },
  exec: function(re, str) {
    var result = (re.exec(str) || [""])[0];
    return { value: result | 0, length: result.length };
  },
  find: function(array, str) {
    var index = -1, length = 0;
    for (var i = 0, len = array.length, item; i < len; i++) {
      item = array[i];
      if (!str.indexOf(item) && item.length > length) {
        index = i;
        length = item.length;
      }
    }
    return { value: index, length };
  },
  pre: function(str) {
    return str;
  },
  res: _res
};
var extend = function(base, props, override, res) {
  var obj = {}, key;
  for (key in base) {
    obj[key] = base[key];
  }
  for (key in props || {}) {
    if (!(!!override ^ !!obj[key])) {
      obj[key] = props[key];
    }
  }
  if (res) {
    obj.res = res;
  }
  return obj;
};
var proto = {
  _formatter,
  _parser
};
var localized_proto;
var date;
proto.compile = function(formatString) {
  var re = /\[([^[\]]|\[[^[\]]*])*]|([A-Za-z])\2+|\.{3}|./g, keys, pattern = [formatString];
  while (keys = re.exec(formatString)) {
    pattern[pattern.length] = keys[0];
  }
  return pattern;
};
proto.format = function(dateObj, arg, utc) {
  var ctx = this || date, pattern = typeof arg === "string" ? ctx.compile(arg) : arg, d = function() {
    if (utc) {
      var u = new Date(dateObj.getTime());
      u.getFullYear = u.getUTCFullYear;
      u.getMonth = u.getUTCMonth;
      u.getDate = u.getUTCDate;
      u.getHours = u.getUTCHours;
      u.getMinutes = u.getUTCMinutes;
      u.getSeconds = u.getUTCSeconds;
      u.getMilliseconds = u.getUTCMilliseconds;
      u.getDay = u.getUTCDay;
      u.getTimezoneOffset = function() {
        return 0;
      };
      return u;
    }
    return dateObj;
  }(), formatter = ctx._formatter, str = "";
  for (var i = 1, len = pattern.length, token; i < len; i++) {
    token = pattern[i];
    str += formatter[token] ? formatter.post(formatter[token](d, pattern[0])) : token.replace(/\[(.*)]/, "$1");
  }
  return str;
};
proto.preparse = function(dateString, arg) {
  var ctx = this || date, pattern = typeof arg === "string" ? ctx.compile(arg) : arg, dt = { Y: 1970, M: 1, D: 1, H: 0, A: 0, h: 0, m: 0, s: 0, S: 0, Z: 0, _index: 0, _length: 0, _match: 0 }, comment = /\[(.*)]/, parser = ctx._parser, offset = 0;
  dateString = parser.pre(dateString);
  for (var i = 1, len = pattern.length, token, result; i < len; i++) {
    token = pattern[i];
    if (parser[token]) {
      result = parser[token](dateString.slice(offset), pattern[0]);
      if (!result.length) {
        break;
      }
      offset += result.length;
      dt[result.token || token.charAt(0)] = result.value;
      dt._match++;
    } else if (token === dateString.charAt(offset) || token === " ") {
      offset++;
    } else if (comment.test(token) && !dateString.slice(offset).indexOf(comment.exec(token)[1])) {
      offset += token.length - 2;
    } else if (token === "...") {
      offset = dateString.length;
      break;
    } else {
      break;
    }
  }
  dt.H = dt.H || parser.h12(dt.h, dt.A);
  dt._index = offset;
  dt._length = dateString.length;
  return dt;
};
proto.parse = function(dateString, arg, utc) {
  var ctx = this || date, pattern = typeof arg === "string" ? ctx.compile(arg) : arg, dt = ctx.preparse(dateString, pattern);
  if (ctx.isValid(dt)) {
    dt.M -= dt.Y < 100 ? 22801 : 1;
    if (utc || ~ctx._parser.find(pattern, "ZZ").value) {
      return new Date(Date.UTC(dt.Y, dt.M, dt.D, dt.H, dt.m + dt.Z, dt.s, dt.S));
    }
    return new Date(dt.Y, dt.M, dt.D, dt.H, dt.m, dt.s, dt.S);
  }
  return /* @__PURE__ */ new Date(NaN);
};
proto.isValid = function(arg1, arg2) {
  var ctx = this || date, dt = typeof arg1 === "string" ? ctx.preparse(arg1, arg2) : arg1, last = [31, 28 + ctx.isLeapYear(dt.Y) | 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][dt.M - 1];
  return !(dt._index < 1 || dt._length < 1 || dt._index - dt._length || dt._match < 1 || dt.Y < 1 || dt.Y > 9999 || dt.M < 1 || dt.M > 12 || dt.D < 1 || dt.D > last || dt.H < 0 || dt.H > 23 || dt.m < 0 || dt.m > 59 || dt.s < 0 || dt.s > 59 || dt.S < 0 || dt.S > 999 || dt.Z < -840 || dt.Z > 720);
};
proto.transform = function(dateString, arg1, arg2, utc) {
  const ctx = this || date;
  return ctx.format(ctx.parse(dateString, arg1), arg2, utc);
};
proto.addYears = function(dateObj, years, utc) {
  return (this || date).addMonths(dateObj, years * 12, utc);
};
proto.addMonths = function(dateObj, months, utc) {
  var d = new Date(dateObj.getTime());
  if (utc) {
    d.setUTCMonth(d.getUTCMonth() + months);
    if (d.getUTCDate() < dateObj.getUTCDate()) {
      return (this || date).addDays(d, -d.getUTCDate(), utc);
    }
  } else {
    d.setMonth(d.getMonth() + months);
    if (d.getDate() < dateObj.getDate()) {
      return (this || date).addDays(d, -d.getDate(), utc);
    }
  }
  return d;
};
proto.addDays = function(dateObj, days, utc) {
  return (this || date).addHours(dateObj, days * 24, utc);
};
proto.addHours = function(dateObj, hours, utc) {
  return (this || date).addMinutes(dateObj, hours * 60, utc);
};
proto.addMinutes = function(dateObj, minutes, utc) {
  return (this || date).addSeconds(dateObj, minutes * 60, utc);
};
proto.addSeconds = function(dateObj, seconds, utc) {
  return (this || date).addMilliseconds(dateObj, seconds * 1e3, utc);
};
proto.addMilliseconds = function(dateObj, milliseconds, utc) {
  var d = new Date(dateObj.getTime());
  if (utc) {
    d.setUTCMilliseconds(d.getUTCMilliseconds() + milliseconds);
  } else {
    d.setMilliseconds(d.getMilliseconds() + milliseconds);
  }
  return d;
};
proto.subtract = function(date1, date2) {
  var delta = date1.getTime() - date2.getTime();
  return {
    toMilliseconds: function() {
      return delta;
    },
    toSeconds: function() {
      return delta / 1e3;
    },
    toMinutes: function() {
      return delta / 6e4;
    },
    toHours: function() {
      return delta / 36e5;
    },
    toDays: function() {
      return delta / 864e5;
    }
  };
};
proto.isLeapYear = function(y) {
  return !(y % 4) && !!(y % 100) || !(y % 400);
};
proto.isSameDay = function(date1, date2) {
  return date1.toDateString() === date2.toDateString();
};
proto.locale = function(code, locale) {
  if (!locales[code]) {
    locales[code] = locale;
  }
};
proto.plugin = function(name, plugin) {
  if (!plugins[name]) {
    plugins[name] = plugin;
  }
};
localized_proto = extend(proto);
date = extend(proto);
date.locale = function(locale) {
  var install = typeof locale === "function" ? locale : date.locale[locale];
  if (!install) {
    return lang;
  }
  lang = install(proto);
  var extension = locales[lang] || {};
  var res = extend(_res, extension.res, true);
  var formatter = extend(_formatter, extension.formatter, true, res);
  var parser = extend(_parser, extension.parser, true, res);
  date._formatter = localized_proto._formatter = formatter;
  date._parser = localized_proto._parser = parser;
  for (var plugin in plugins) {
    date.extend(plugins[plugin]);
  }
  return lang;
};
date.extend = function(extension) {
  var res = extend(date._parser.res, extension.res);
  var extender = extension.extender || {};
  date._formatter = extend(date._formatter, extension.formatter, false, res);
  date._parser = extend(date._parser, extension.parser, false, res);
  for (var key in extender) {
    if (!date[key]) {
      date[key] = extender[key];
    }
  }
};
date.plugin = function(plugin) {
  var install = typeof plugin === "function" ? plugin : date.plugin[plugin];
  if (install) {
    date.extend(plugins[install(proto, localized_proto)] || {});
  }
};
var date$1 = date;
export {
  date$1 as default
};
/*! Bundled license information:

date-and-time/esm/date-and-time.mjs:
  (**
   * @preserve date-and-time (c) KNOWLEDGECODE | MIT
   *)
*/
//# sourceMappingURL=date-and-time.js.map
